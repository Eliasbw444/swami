/* -*- Mode: C -*-
 *
 * ipatch.override - Function override for libInstPatch python binding
 *
 * libInstPatch
 * Copyright (C) 1999-2002 Josh Green <jgreen@users.sourceforge.net>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */
%%
headers
#include <Python.h>
#include "pygobject.h"
#include <libinstpatch/libinstpatch.h>
%%
modulename InstPatch
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob
  *_get_type
  ipatch_list_*
  ipatch_*_first
  ipatch_*_next
%%
ignore
  _ipatch_code_error
  _ipatch_code_errorv
  IpatchList
  ipatch_container_init_iter
  ipatch_container_insert_iter
  ipatch_container_remove_iter
  ipatch_container_set_add_hook
  ipatch_container_set_remove_hook
  ipatch_dls2_info_install_class_properties
  ipatch_dls2_info_set
  ipatch_dls2_info_set_property
  ipatch_dls2_sample_info_install_class_properties
  ipatch_dls2_sample_info_set_property
  ipatch_error_quark
  ipatch_file_default_read_method
  ipatch_file_default_seek_method
  ipatch_file_default_write_method
  ipatch_file_get_iofuncs
  ipatch_file_open_with_io_channel
  ipatch_file_ref_io_channel
  ipatch_file_set_iofuncs
  ipatch_file_set_iofuncs_static
  ipatch_gerror_message
  ipatch_gig_parse_effects
  ipatch_gig_region_last
  ipatch_gig_region_previous
  ipatch_item_get_atomic
  ipatch_item_get_hooks
  ipatch_item_set_atomic
  ipatch_item_set_hooks
  ipatch_item_set_prop_notify_hook
  ipatch_iter_alloc
  ipatch_riff_parser_error_quark
  ipatch_sample_install_property
  ipatch_sample_install_property_readonly
  ipatch_sample_new_property_param_spec
  ipatch_sample_new_transform_func_array
  ipatch_sample_store_RAM_get_location
  ipatch_sample_store_RAM_set_location
  ipatch_sf2_free_info_array
  ipatch_sf2_gen_amount_to_value
  ipatch_sf2_get_info
  ipatch_sf2_parse_bag
  ipatch_sf2_parse_gen
  ipatch_sf2_parse_ihdr
  ipatch_sf2_parse_mod
  ipatch_sf2_parse_phdr
  ipatch_sf2_parse_shdr
  ipatch_sf2_set_info
  ipatch_sf2_zone_class_install_gen_properties
  ipatch_sf2_zone_genid_get_pspec
%%
override ipatch_container_get_children kwargs
static PyObject *
_wrap_ipatch_container_get_children (PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
  static char *kwlist[] = { "type", NULL };
  PyObject *py_type = NULL;
  GType type;
  IpatchList *list;
  PyObject *py_list;
  GList *p;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs,
				    "O:IpatchContainer.get_children",
				    kwlist, &py_type)) return NULL;
  if ((type = pyg_type_from_object (py_type)) == 0) return NULL;

  /* ++ ref new list */
  list = ipatch_container_get_children (IPATCH_CONTAINER (self->obj), type);

  if ((py_list = PyList_New (0)) == NULL)
    {
      g_object_unref (list);	/* -- unref list */
      return (NULL);
    }

  for (p = list->items; p != NULL; p = g_list_next (p))
    {
      PyObject *obj = pygobject_new (G_OBJECT (p->data));
      if (obj == NULL)
	{
	  g_object_unref (list); /* -- unref list */
	  Py_DECREF (py_list);
	  return (NULL);
	}
      PyList_Append (py_list, obj);
      Py_DECREF (obj);
    }
  g_object_unref (list);	/* -- unref list */
  return (py_list);
}
%%
override ipatch_container_get_child_types noargs
static PyObject *
_wrap_ipatch_container_get_child_types (PyGObject *self)
{
  const GType *types;
  PyObject *py_list;

  if ((py_list = PyList_New (0)) == NULL) return (NULL);

  types = ipatch_container_get_child_types (IPATCH_CONTAINER (self->obj));
  for (; *types != 0; types++)
    {
      PyObject *py_type = pyg_type_wrapper_new (*types);
      if (py_type == NULL)
	{
	  Py_DECREF (py_list);
	  return (NULL);
	}
      PyList_Append (py_list, py_type);
      Py_DECREF (py_type);
    }
  return (py_list);
}
%%
override ipatch_container_type_get_child_types kwargs
static PyObject *
_wrap_ipatch_container_type_get_child_types (PyGObject *self, PyObject *args,
					     PyObject *kwargs)
{
  static char *kwlist[] = { "type", NULL };
  const GType *types;
  PyObject *py_type = NULL;
  PyObject *py_list;
  GType container_type;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O:container_type_children",
				    kwlist, &py_type)) return NULL;
  if ((container_type = pyg_type_from_object (py_type)) == 0) return NULL;

  if ((py_list = PyList_New (0)) == NULL) return (NULL);

  types = ipatch_container_type_get_child_types (container_type);
  for (; *types != 0; types++)
    {
      PyObject *py_type = pyg_type_wrapper_new (*types);
      if (py_type == NULL)
	{
	  Py_DECREF (py_list);
	  return (NULL);
	}
      PyList_Append (py_list, py_type);
      Py_DECREF (py_type);
    }
  return (py_list);
}
%%
override-slot IpatchList.tp_iter

typedef struct
{
  PyObject_HEAD
  GList *curpos;
} PyIpatchListIter;

static void
pyipatch_list_iter_dealloc(PyIpatchListIter *self)
{
  PyObject_Del((PyObject*) self);
}

static PyObject*
pyipatch_list_iter_next(PyIpatchListIter *iter)
{
  PyObject *pyobj;

  if (!iter->curpos)
  {
      PyErr_SetNone(PyExc_StopIteration);
      return NULL;
  }

  pyobj = pygobject_new ((GObject *)(iter->curpos->data));
  iter->curpos = g_list_next (iter->curpos);

  return pyobj;
}

PyTypeObject PyIpatchListIter_Type = {
  PyObject_HEAD_INIT(NULL)
  0,					/* ob_size */
  "ipatch.ListIter",			/* tp_name */
  sizeof(PyIpatchListIter),		/* tp_basicsize */
  0,					/* tp_itemsize */
  (destructor)pyipatch_list_iter_dealloc,	/* tp_dealloc */
  0,					/* tp_print */
  0,					/* tp_getattr */
  0,					/* tp_setattr */
  0,					/* tp_compare */
  0,					/* tp_repr */
  0,					/* tp_as_number */
  0,					/* tp_as_sequence */
  0,		       			/* tp_as_mapping */
  0,					/* tp_hash */
  0,					/* tp_call */
  0,					/* tp_str */
  0,					/* tp_getattro */
  0,					/* tp_setattro */
  0,					/* tp_as_buffer */
  Py_TPFLAGS_DEFAULT,			/* tp_flags */
  "IpatchList iterator",			/* tp_doc */
  0,					/* tp_traverse */
  0,					/* tp_clear */
  0,					/* tp_richcompare */
  0,					/* tp_weaklistoffset */
  0,					/* tp_iter */
  (iternextfunc)pyipatch_list_iter_next, /* tp_iternext */
};

static PyObject*
_wrap_ipatch_list_tp_iter(PyGObject *self)
{
  PyIpatchListIter *iter;
  iter = PyObject_NEW(PyIpatchListIter, &PyIpatchListIter_Type);
  iter->curpos = IPATCH_LIST (self->obj)->items;
  return (PyObject *) iter;
}
%%
override-slot IpatchRange.tp_as_sequence
static int
_wrap_ipatch_range_length(PyGBoxed *self)
{
    return 2;
}
static PyObject *
_wrap_ipatch_range_getitem(PyGBoxed *self, int pos)
{
    IpatchRange *range;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return NULL;
    }
    range = pyg_boxed_get(self, IpatchRange);

    switch (pos) {
    case 0: return PyInt_FromLong(range->low);
    case 1: return PyInt_FromLong(range->high);
    default:
        g_assert_not_reached();
        return NULL;
    }
}
static int
_wrap_ipatch_range_setitem(PyGBoxed *self, int pos, PyObject *value)
{
    IpatchRange *range;
    gint val;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return -1;
    }

    range = pyg_boxed_get(self, IpatchRange);
    val = PyInt_AsLong(value);
    if (PyErr_Occurred()) return -1;

    switch(pos) {
    case 0: range->low = val; break;
    case 1: range->high = val; break;
    default:
        g_assert_not_reached();
        return -1;
    }
    return 0;
}
static PySequenceMethods _wrap_ipatch_range_tp_as_sequence = {
    (inquiry)_wrap_ipatch_range_length,
    (binaryfunc)0,
    (intargfunc)0,
    (intargfunc)_wrap_ipatch_range_getitem,
    (intintargfunc)0,
    (intobjargproc)_wrap_ipatch_range_setitem,
    (intintobjargproc)0
};
%%
override-attr IpatchRange.low
static int
_wrap_ipatch_range__set_low(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred()) return -1;
    pyg_boxed_get(self, IpatchRange)->low = val;
    return 0;
}
%%
override-attr IpatchRange.high
static int
_wrap_ipatch_range__set_high(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred()) return -1;
    pyg_boxed_get(self, IpatchRange)->high = val;
    return 0;
}
%%
override ipatch_cram_decoder_next_file noargs
static PyObject *
_wrap_ipatch_cram_decoder_next_file(PyGObject *self)
{
    IpatchCramDecoderFileInfo *info;
    GError *err = NULL;
    
    info = ipatch_cram_decoder_next_file(IPATCH_CRAM_DECODER(self->obj), &err);
    
    if (pyg_error_check(&err))
        return NULL;

    if (!info) Py_RETURN_NONE;

    /* FIXME - 32 bit support only, 64 bit numbers truncated? */
    return (Py_BuildValue ("{s:s,s:i,s:i,s:i,s:i}",
                           "filename", info->filename,
                           "size", (int)(info->size),
                           "compress_size", (int)(info->compress_size),
                           "date", info->date,
                           "flags", info->flags));
}
