<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.2  (Linux)">
	<META NAME="CREATED" CONTENT="20070505;13404100">
	<META NAME="CHANGEDBY" CONTENT="Josh Green">
	<META NAME="CHANGED" CONTENT="20070602;15451500">
	<STYLE TYPE="text/css">
	<!--
		@page { size: 8.5in 11in; margin: 0.79in }
		P { margin-bottom: 0.08in }
		H1 { margin-bottom: 0.08in }
		H1.western { font-family: "Arial", sans-serif; font-size: 16pt }
		H1.cjk { font-family: "Andale Sans UI"; font-size: 16pt }
		H1.ctl { font-family: "Tahoma"; font-size: 16pt }
		H2 { margin-bottom: 0.08in }
		H2.western { font-family: "Arial", sans-serif; font-size: 14pt; font-style: italic }
		H2.cjk { font-size: 14pt; font-style: italic }
		H2.ctl { font-family: "Tahoma"; font-size: 14pt; font-style: italic }
		H3 { margin-bottom: 0.08in }
		H3.western { font-family: "Arial", sans-serif }
		H3.ctl { font-family: "Tahoma" }
		TD P { margin-bottom: 0in }
		P.sdfootnote { margin-left: 0.2in; text-indent: -0.2in; margin-bottom: 0in; font-size: 10pt }
		A.sdfootnoteanc { font-size: 57% }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<P ALIGN=CENTER STYLE="margin-bottom: 0in"><FONT SIZE=4 STYLE="font-size: 16pt"><B>CRAM
Format Specification</B></FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><B>Author: </B><SPAN STYLE="font-weight: medium">Josh
Green &lt;</SPAN><A HREF="mailto:josh@resonance.org"></A><A HREF="mailto:josh@resonance.org"></A><A HREF="mailto:josh@resonance.org"><SPAN STYLE="font-weight: medium">josh@resonance.org</SPAN></A><A HREF="mailto:josh@resonance.org"></A><A HREF="mailto:josh@resonance.org"></A><SPAN STYLE="font-weight: medium">&gt;</SPAN></P>
<P STYLE="margin-bottom: 0in"><B>Revision:</B><SPAN STYLE="font-weight: medium">
1.2</SPAN></P>
<P STYLE="margin-bottom: 0in"><B>Date:</B><SPAN STYLE="font-weight: medium">
May 19, 2007</SPAN></P>
<P STYLE="margin-bottom: 0in"><B>URL:</B><SPAN STYLE="font-weight: medium">
</SPAN><A HREF="http://cram.resonance.org/"></A><A HREF="http://cram.resonance.org/"></A><A HREF="http://cram.resonance.org/"><SPAN STYLE="font-weight: medium">http://cram.resonance.org</SPAN></A><A HREF="http://cram.resonance.org/"></A><A HREF="http://cram.resonance.org/"></A></P>
<P STYLE="margin-bottom: 0in; font-weight: medium"><BR>
</P>
<DIV ID="Table of Contents1" DIR="LTR">
	<DIV ID="Table of Contents1_Head" DIR="LTR">
		<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Arial, sans-serif"><FONT SIZE=4 STYLE="font-size: 16pt"><B>Table
		of Contents</B></FONT></FONT></P>
	</DIV>
	<P STYLE="margin-bottom: 0in">1 <A HREF="#1.Revision history|outline">Revision
	history</A>	2</P>
	<P STYLE="margin-bottom: 0in">2 <A HREF="#2.About|outline">About</A>	3</P>
	<P STYLE="margin-bottom: 0in">3 <A HREF="#3.Features|outline">Features</A>	3</P>
	<P STYLE="margin-bottom: 0in">4 <A HREF="#4.File extensions|outline">File
	extensions</A>	3</P>
	<P STYLE="margin-bottom: 0in">5 <A HREF="#5.File identification|outline">File
	identification</A>	3</P>
	<P STYLE="margin-bottom: 0in">6 <A HREF="#6.EBML format|outline">EBML
	format</A>	4</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">6.1 <A HREF="#6.1.Variable length integers|outline">Variable
	length integers</A>	4</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">6.2 <A HREF="#6.2.EBML chunks|outline">EBML
	chunks</A>	4</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">6.3 <A HREF="#6.3.Data types|outline">Data
	types</A>	5</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">6.4 <A HREF="#6.4.CRC32 checksums|outline">CRC32
	checksums</A>	5</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">6.5 <A HREF="#6.5.Errata|outline">Errata</A>	5</P>
	<P STYLE="margin-bottom: 0in">7 <A HREF="#7.CRAM format reference|outline">CRAM
	format reference</A>	6</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">7.1 <A HREF="#7.1.CRAM file format|outline">CRAM
	file format</A>	6</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">7.2 <A HREF="#7.2.FileChunk|outline">FileChunk</A>	6</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">7.3 <A HREF="#7.3.Relocation table|outline">Relocation
	table</A>	7</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">7.4 <A HREF="#7.4.Chunks listed by EBML ID|outline">Chunks
	listed by EBML ID</A>	8</P>
	<P STYLE="margin-bottom: 0in">8 <A HREF="#8.Cram format description|outline">Cram
	format description</A>	9</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">8.1 <A HREF="#8.1.CRAM format version history|outline">CRAM
	format version history</A>	9</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">8.2 <A HREF="#8.2.EBML chunk|outline">EBML
	chunk</A>	10</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">8.3 <A HREF="#8.3.CramInfo chunk|outline">CramInfo
	chunk</A>	10</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">8.4 <A HREF="#8.4.Flags|outline">Flags</A>	10</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">8.5 <A HREF="#8.5.FileChunk|outline">FileChunk</A>	11</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">8.6 <A HREF="#8.6.Grouping audio segments|outline">Grouping
	audio segments</A>	11</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">8.7 <A HREF="#8.7.Relocation table|outline">Relocation
	table</A>	12</P>
	<P STYLE="margin-left: 0.39in; margin-bottom: 0in">8.7.1
	<A HREF="#8.7.1.BinaryChunk|outline">BinaryChunk</A>	12</P>
	<P STYLE="margin-left: 0.39in; margin-bottom: 0in">8.7.2 <A HREF="#8.7.2.FlacChunk and WavPackChunk|outline">FlacChunk
	and WavPackChunk</A>	12</P>
	<P STYLE="margin-left: 0.39in; margin-bottom: 0in">8.7.3
	<A HREF="#8.7.3.FlacSplitChunk and WavPackSplitChunk|outline">FlacSplitChunk
	and WavPackSplitChunk</A>	12</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">8.8 <A HREF="#8.8.CRAM hybrid lossless|outline">CRAM
	hybrid lossless</A>	13</P>
	<P STYLE="margin-left: 0.39in; margin-bottom: 0in">8.8.1 <A HREF="#8.8.1.CRAM correction file|outline">CRAM
	correction file</A>	13</P>
	<P STYLE="margin-bottom: 0in">9 <A HREF="#9.Implementation notes|outline">Implementation
	notes</A>	14</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">9.1 <A HREF="#9.1.EBML chunk handling|outline">EBML
	chunk handling</A>	14</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">9.2 <A HREF="#9.2.Binary compression|outline">Binary
	compression</A>	14</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">9.3 <A HREF="#9.3.Audio compression|outline">Audio
	compression</A>	14</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">9.4 <A HREF="#9.4.FLAC compression|outline">FLAC
	compression</A>	14</P>
	<P STYLE="margin-left: 0.2in; margin-bottom: 0in">9.5 <A HREF="#9.5.CRAM lossy files|outline">CRAM
	lossy files</A>	14</P>
</DIV>
<P STYLE="margin-bottom: 0in; font-weight: medium"><BR>
</P>
<H1 CLASS="western" STYLE="page-break-before: always"><A NAME="1.Revision history|outline"></A>
1Revision history</H1>
<P><B>Revision 1.2</B><SPAN STYLE="font-weight: medium"> &ndash; May
19, 2007</SPAN></P>
<UL>
	<LI><P STYLE="font-weight: medium">Switched to using non variable
	length encoded integers for fields, breaking backwards
	compatibility.</P>
	<LI><P STYLE="font-weight: medium">Format version reset to <B>v1</B>
	(since it wasn't stored properly in older versions anyways)</P>
	<LI><P STYLE="font-weight: medium">Previous versions (1-3) renamed
	to (0x81 &ndash; 0x83), to indicate the falsely stored version
	values</P>
	<LI><P STYLE="font-weight: medium">DocType field should now come
	directly after the EBML chunk, to aid in file identification</P>
	<LI><P STYLE="font-weight: medium">Added CRAMInfo chunk to contain
	Flags, Software and Comment fields.  This was done so that the
	DocType signature is always a fixed offset (EBML chunk size always 1
	byte), to aid in file identification.</P>
	<LI><P STYLE="font-weight: medium">Added section on file
	identification including Unix <B>file</B><SPAN STYLE="font-weight: medium">
	utility magic.</SPAN></P>
	<LI><P STYLE="font-weight: medium">Removed AudioMD5 chunk and added
	FileMD5 chunk. This means that FileMD5 now requires a separate pass
	(needed anyways for out of order binary chunk storage).  Section
	added in FileChunk description on MD5 sums.</P>
	<LI><P STYLE="font-weight: medium">WavPackSplitChunk and
	FlacSplitChunk no longer used at the FileData level, since
	WavPackChunk and FlacChunk can be used for both split or non-split
	audio.</P>
	<LI><P STYLE="font-weight: medium">CramInfo and Software field are
	now required, set max size of Software field to 64 bytes and Comment
	to 4096 bytes.</P>
	<LI><P STYLE="font-weight: medium">EBMLVersion and EBMLReadVersion
	chunks no longer used (DocTypeVersion covers it).</P>
	<LI><P STYLE="font-weight: medium">Added FileInfo chunk to contain
	information related fields.</P>
	<LI><P STYLE="font-weight: medium">Added optional CRC-32 for
	CramInfo and FileInfo chunks.</P>
	<LI><P STYLE="font-weight: medium">Chunk order should now be
	considered fixed to make it easier on the decoder implementation</P>
</UL>
<P><B>Revision 1.1</B><SPAN STYLE="font-weight: medium"> &ndash; May
11, 2007</SPAN></P>
<UL>
	<LI><P STYLE="font-weight: medium">Updated EBML ID tables to not use
	indentation (didn't work in HTML export)</P>
	<LI><P STYLE="font-weight: medium"><SPAN STYLE="font-weight: medium">Added
	SetAudioEntry and NextAudioEntry chunks for chaining audio segments
	and section on </SPAN><A HREF="#7.5.Grouping audio segments|outline"></A><A HREF="#7.5.Grouping audio segments|outline"></A><A HREF="#7.5.Grouping audio segments|outline"><SPAN STYLE="font-weight: medium">grouping
	audio segments</SPAN></A><A HREF="#7.5.Grouping audio segments|outline"></A><A HREF="#7.5.Grouping audio segments|outline"></A></P>
	<LI><P STYLE="font-weight: medium">Clarification of RawSize for
	SampleSplit audio entries</P>
	<LI><P STYLE="font-weight: medium">Added VerbatimChunk type</P>
	<LI><P STYLE="font-weight: medium">Added signed int data type</P>
	<LI><P STYLE="font-weight: medium">Other minor clarifications</P>
</UL>
<P><B>Revision 1.0</B><SPAN STYLE="font-weight: medium"> &ndash; May
5, 2007</SPAN></P>
<UL>
	<LI VALUE=1><P><SPAN STYLE="font-weight: medium">Initial release of
	document describing </SPAN><B>CRAM</B><SPAN STYLE="font-weight: medium">
	format version 4 (actually v1).</SPAN></P>
</UL>
<P><BR><BR>
</P>
<P STYLE="margin-bottom: 0in; page-break-before: always"><BR>
</P>
<H1 CLASS="western"><A NAME="2.About|outline"></A>2About</H1>
<P STYLE="margin-bottom: 0in"><B>CRAM</B> is an acronym for &ldquo;<B>C</B>ompress
hyb<B>R</B>id <B>A</B>udio <B>M</B>edia&rdquo;.  It is an open file
format that was created to handle the compression of files containing
audio and binary.  Better compression of audio can often be achieved
by codecs specifically designed for audio (such as <A HREF="http://flac.sourceforge.net/"></A><A HREF="http://flac.sourceforge.net/"></A><A HREF="http://flac.sourceforge.net/"><B>FLAC</B></A><A HREF="http://flac.sourceforge.net/"></A><A HREF="http://flac.sourceforge.net/"></A>
or <A HREF="http://www.wavpack.com/"></A><A HREF="http://www.wavpack.com/"></A><A HREF="http://www.wavpack.com/"><B>WavPack</B></A><A HREF="http://www.wavpack.com/"></A><A HREF="http://www.wavpack.com/"></A>)
than a binary compressor<SPAN STYLE="font-weight: medium">.  CRAM
utilizes audio codecs for audio (FLAC and WavPack currently) and
binary compressors for binary (</SPAN><B>bzlib </B><SPAN STYLE="font-weight: medium">and
</SPAN><B>zlib </B><SPAN STYLE="font-weight: medium">currently) which
often yields a much higher compression ratio than if a purely binary
compressor was used.  Format specific encoders are created to handle
the compression of a specific data format, but the decoder is
generic, which means future support for the compression of other
formats is backwards compatible.  CRAM is currently specifically used
for instrument file compression (such as </SPAN><B>SoundFont</B><FONT FACE="Times New Roman, serif"><B>&copy;</B></FONT><FONT FACE="Times New Roman, serif"><B><A CLASS="sdfootnoteanc" NAME="sdfootnote1anc" HREF="#sdfootnote1sym"><SUP>1</SUP></A></B></FONT><SPAN STYLE="font-weight: medium">,
</SPAN><B>DLS</B><SPAN STYLE="font-weight: medium"> and
</SPAN><B>GigaSampler</B><FONT FACE="Times New Roman, serif"><B>&copy;</B></FONT><FONT FACE="Times New Roman, serif"><B><A CLASS="sdfootnoteanc" NAME="sdfootnote2anc" HREF="#sdfootnote2sym"><SUP>2</SUP></A></B></FONT><SPAN STYLE="font-weight: medium">),
but is not limited to this purpose.</SPAN></P>
<H1 CLASS="western"><A NAME="3.Features|outline"></A>3Features</H1>
<UL>
	<LI><P>Open standard with <B>LGPL</B> licensed reference software
	implementation (<A HREF="http://libinstpatch.resonance.org/"></A><A HREF="http://libinstpatch.resonance.org/"></A><A HREF="http://libinstpatch.resonance.org/"><B>libInstPatch</B></A><A HREF="http://libinstpatch.resonance.org/"></A><A HREF="http://libinstpatch.resonance.org/"></A>)</P>
	<LI><P>Based on <A HREF="http://ebml.sourceforge.net/"></A><A HREF="http://ebml.sourceforge.net/"></A><A HREF="http://ebml.sourceforge.net/"><B>EBML</B></A><A HREF="http://ebml.sourceforge.net/"></A><A HREF="http://ebml.sourceforge.net/"></A>
	(a binary XML like format) which provides flexibility in extending
	the format</P>
	<LI><P>Compression of multiple files with paths in a single archive
	with time preservation</P>
	<LI><P>Extensive audio format support including: 8/16/24/32 bit
	integer sample widths, floating point audio (<B>WavPack </B><SPAN STYLE="font-weight: medium">only),
	stereo or mono (support for up to 8 audio channels is planned),
	signed or unsigned, big endian or little endian</SPAN></P>
	<LI><P><SPAN STYLE="font-weight: medium">Support for split stereo
	(mono audio segment pairs stored separately) and split sample data
	(such as 24 bit support in </SPAN><B>SoundFont</B><FONT FACE="Times New Roman, serif"><B>&copy;</B></FONT><SPAN STYLE="font-weight: medium">
	files where 16 bit and 8 bit sample width portions are stored
	separately).</SPAN></P>
	<LI><P><SPAN STYLE="font-weight: medium">Lossy/lossless hybrid mode
	(</SPAN><B>WavPack</B><SPAN STYLE="font-weight: medium"> only) where
	a much smaller lossy CRAM file can be stored with a separate
	correction file which when combined results in the original lossless
	data. The combined sizes of the files are only slightly larger than
	the equivalent lossless CRAM file.  This allows for the creation of
	a smaller preview of a potentially large file.</SPAN></P>
</UL>
<H1 CLASS="western"><A NAME="4.File extensions|outline"></A>4File
extensions</H1>
<P>There are 3 file extensions used with CRAM.</P>
<OL>
	<LI><P><B>.cram</B><SPAN STYLE="font-weight: medium"> &ndash; Used
	for lossless CRAM files</SPAN></P>
	<LI><P><B>.craml</B><SPAN STYLE="font-weight: medium"> &ndash; Lossy
	CRAM file</SPAN></P>
	<LI><P><B>.cramc</B><SPAN STYLE="font-weight: medium"> &ndash; CRAM
	correction file</SPAN></P>
</OL>
<H1 CLASS="western" STYLE="font-weight: medium"><A NAME="5.File identification|outline"></A>
5File identification</H1>
<P><SPAN STYLE="font-weight: medium">A CRAM file can be identified by
the four EBML bytes 0x1A 0x45 0xDF 0xA3 at the beginning of the file.
 At offset 5 will be found the DocType ID consisting of 2 bytes 0x42
0x82.  At offset 8 will be found the characters &ldquo;CRAM&rdquo;,
&ldquo;CRAML&rdquo; or &ldquo;CRAMC&rdquo; for a lossless, lossy or
correction CRAM file respectively.  Below is the corresponding magic
for the Unix </SPAN><B>file</B><SPAN STYLE="font-weight: medium">
utility.</SPAN></P>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P><FONT FACE="Nimbus Mono L, monospace"># EBML id: </FONT>
			</P>
			<P><FONT FACE="Nimbus Mono L, monospace">0               belong   
			      0x1a45dfa3 </FONT>
			</P>
			<P><FONT FACE="Nimbus Mono L, monospace"># DocType id: </FONT>
			</P>
			<P><FONT FACE="Nimbus Mono L, monospace">&gt;5             
			beshort         0x4282 </FONT>
			</P>
			<P><FONT FACE="Nimbus Mono L, monospace"># DocType contents: </FONT>
			</P>
			<P><FONT FACE="Nimbus Mono L, monospace">&gt;&gt;8            
			string          CRAM        CRAM archive data</FONT></P>
			<P><FONT FACE="Nimbus Mono L, monospace">&gt;&gt;8            
			string          CRAML       CRAM lossy archive data</FONT></P>
			<P><FONT FACE="Nimbus Mono L, monospace">&gt;&gt;8            
			string          CRAMC       CRAM correction data</FONT></P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<H1 CLASS="western"><A NAME="6.EBML format|outline"></A><B>6EBML
format</B></H1>
<P><SPAN STYLE="font-weight: medium">The following is an overview of
the </SPAN><B>EBML</B><SPAN STYLE="font-weight: medium"> format,
which is likely enough information to utilize the CRAM format.  More
information can be found though, on the </SPAN><A HREF="http://ebml.sourceforge.net/"></A><A HREF="http://ebml.sourceforge.net/"></A><A HREF="http://ebml.sourceforge.net/"><SPAN STYLE="font-weight: medium">EBML
website.</SPAN></A><A HREF="http://ebml.sourceforge.net/"></A><A HREF="http://ebml.sourceforge.net/"></A></P>
<H2 CLASS="western" STYLE="font-weight: medium"><A NAME="4.1.Variable length integers|outline"></A><A NAME="4.1.Variable length integers|outline"></A><A NAME="4.1.Variable length integers|outline"></A><A NAME="6.1.Variable length integers|outline"></A>
6.1Variable length integers</H2>
<P><SPAN STYLE="font-weight: medium">One feature of EBML is variable
length encoded integers.  This is used for EBML chunk IDs and sizes. 
Of note is that </SPAN><B>uint</B><SPAN STYLE="font-weight: medium">
and </SPAN><B>int </B><SPAN STYLE="font-weight: medium">field values
are not variable length encoded (the length of the integer can be
inferred from the chunk size, this was also broken in previous CRAM
format versions).  EBML</SPAN><B> </B><SPAN STYLE="font-weight: medium">stores
integer values in </SPAN><B>big endian</B><SPAN STYLE="font-weight: medium">
byte order.  </SPAN><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: medium">The
count of 0 bits in the first byte (starting from the most significant
bit) + 1 determines the number of bytes that the integer is composed
of.  T</SPAN></SPAN><SPAN STYLE="font-weight: medium">he following
table illustrates this:</SPAN></P>
<TABLE WIDTH=658 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=38>
	<COL WIDTH=178>
	<COL WIDTH=195>
	<COL WIDTH=212>
	<TR VALIGN=TOP>
		<TD WIDTH=38>
			<P><B>Size</B></P>
		</TD>
		<TD WIDTH=178>
			<P><B>Range start (hex)</B></P>
		</TD>
		<TD WIDTH=195>
			<P><B>Range end (hex)</B></P>
		</TD>
		<TD WIDTH=212>
			<P><B>Effective range (decimal)</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=38>
			<P>1</P>
		</TD>
		<TD WIDTH=178>
			<P>0x80</P>
		</TD>
		<TD WIDTH=195>
			<P>0xFE</P>
		</TD>
		<TD WIDTH=212>
			<P>0 to 2^7 - 2</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=38>
			<P>2</P>
		</TD>
		<TD WIDTH=178>
			<P>0x4000</P>
		</TD>
		<TD WIDTH=195>
			<P>0x7FFE</P>
		</TD>
		<TD WIDTH=212>
			<P>0 to 2^14 - 2</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=38>
			<P>3</P>
		</TD>
		<TD WIDTH=178>
			<P>0x200000</P>
		</TD>
		<TD WIDTH=195>
			<P>0x3FFFFE</P>
		</TD>
		<TD WIDTH=212>
			<P>0 to 2^21 - 2</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=38>
			<P>4</P>
		</TD>
		<TD WIDTH=178>
			<P>0x10000000</P>
		</TD>
		<TD WIDTH=195>
			<P>0x1FFFFFFE</P>
		</TD>
		<TD WIDTH=212>
			<P>0 to 2^28 - 2</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=38>
			<P>5</P>
		</TD>
		<TD WIDTH=178>
			<P>0x0800000000</P>
		</TD>
		<TD WIDTH=195>
			<P>0x0FFFFFFFFE</P>
		</TD>
		<TD WIDTH=212>
			<P>0 to 2^35 - 2</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=38>
			<P>6</P>
		</TD>
		<TD WIDTH=178>
			<P>0x040000000000</P>
		</TD>
		<TD WIDTH=195>
			<P>0x07FFFFFFFFFE</P>
		</TD>
		<TD WIDTH=212>
			<P>0 to 2^42 - 2</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=38>
			<P>7</P>
		</TD>
		<TD WIDTH=178>
			<P>0x02000000000000</P>
		</TD>
		<TD WIDTH=195>
			<P>0x03FFFFFFFFFFFE</P>
		</TD>
		<TD WIDTH=212>
			<P>0 to 2^49 - 2</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=38>
			<P>8</P>
		</TD>
		<TD WIDTH=178>
			<P>0x0100000000000000</P>
		</TD>
		<TD WIDTH=195>
			<P>0x01FFFFFFFFFFFFFE</P>
		</TD>
		<TD WIDTH=212>
			<P>0 to 2^56 - 2</P>
		</TD>
	</TR>
</TABLE>
<PRE></PRE><P STYLE="margin-bottom: 0in; font-style: normal">
<B>For example:</B><SPAN STYLE="font-weight: medium"> A value of 64
decimal (0x40 hex) could be stored as a single byte 0xC0, as a 2 byte
integer 0x4040, as a 3 byte integer 0x200040, etc.  A larger value
such as 8192 decimal (0x2000 hex) would require at least 2 bytes to
encode (0x6000).  In this way values up to </SPAN><B>2</B><SUP><B>56</B></SUP><B>
- 2</B><SPAN STYLE="font-weight: medium"> can be stored in a space
efficient manner (thats 72057594037927934 decimal).</SPAN></P>
<H2 CLASS="western" STYLE="font-weight: medium"><A NAME="6.2.EBML chunks|outline"></A>
6.2EBML chunks</H2>
<P STYLE="font-weight: medium">An EBML chunk can be illustrated by
the following table:</P>
<TABLE WIDTH=658 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=116>
	<COL WIDTH=334>
	<COL WIDTH=182>
	<TR VALIGN=TOP>
		<TD WIDTH=116>
			<P><B>Field Name</B></P>
		</TD>
		<TD WIDTH=334>
			<P><B>Data Type</B></P>
		</TD>
		<TD WIDTH=182>
			<P><B>Example</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=116>
			<P>ID</P>
		</TD>
		<TD WIDTH=334>
			<P>Variable length integer</P>
		</TD>
		<TD WIDTH=182>
			<P>(1A)(45)(DF)(A3)</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=116>
			<P>Size</P>
		</TD>
		<TD WIDTH=334>
			<P>Variable length integer</P>
		</TD>
		<TD WIDTH=182>
			<P>(C0)</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=116>
			<P>Data</P>
		</TD>
		<TD WIDTH=334>
			<P>Arbitrary binary data of <B>Size</B><SPAN STYLE="font-weight: medium">
			bytes</SPAN></P>
		</TD>
		<TD WIDTH=182>
			<P>64 bytes follow</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="font-weight: medium"><BR><BR>
</P>
<P STYLE="font-weight: medium">To summarize: An EBML chunk consists
of an ID, Size and the actual data of the chunk.  The ID and Size are
<A HREF="#4.1.Variable length integers|outline"></A><A HREF="#4.1.Variable length integers|outline"></A><A HREF="#4.1.Variable length integers|outline">variable
length integers</A><A HREF="#4.1.Variable length integers|outline"></A><A HREF="#4.1.Variable length integers|outline"></A>
and the data in the chunk is arbitrary, although a format using EBML
(such as CRAM) defines specific IDs for particular types of data.</P>
<P><B>Example description</B></P>
<P STYLE="font-weight: medium">In the above example the EBML ID is
defined by 4 bytes (1A)(45)(DF)(A3), which is the EBML top level
document ID.  Following the ID is the size field which is stored as a
single byte (C0) byte which has an effective value of 64 decimal. 
The payload of the chunk then follows at 64 bytes in size (in this
case the payload would consist of additional EBML chunks, since the
ID corresponds with the toplevel EBML document chunk).</P>
<H2 CLASS="western" STYLE="font-weight: medium"><A NAME="4.3.Data types|outline"></A><A NAME="4.3.Data types|outline"></A><A NAME="4.3.Data types|outline"></A><A NAME="6.3.Data types|outline"></A>
6.3Data types</H2>
<P STYLE="margin-bottom: 0in; font-style: normal; font-weight: medium">
There are a number of predefined data types for use in EBML files and
there are some additional ones that CRAM uses.  The data types used
by CRAM include:</P>
<P STYLE="margin-bottom: 0in; font-style: normal; font-weight: medium">
<BR>
</P>
<TABLE WIDTH=665 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=128>
	<COL WIDTH=519>
	<TR VALIGN=TOP>
		<TD WIDTH=128>
			<P><B>Data Type Name</B></P>
		</TD>
		<TD WIDTH=519>
			<P><B>Description</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128>
			<P>uint</P>
		</TD>
		<TD WIDTH=519>
			<P>Integer from 1 to 8 bytes (not variable length encoded, since
			size can already be inferred from chunk size).</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128>
			<P>int</P>
		</TD>
		<TD WIDTH=519>
			<P>Like uint but the value is interpreted as a signed integer.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128>
			<P>string</P>
		</TD>
		<TD WIDTH=519>
			<P>Printable ASCII (0x20 to 0x7E)</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128>
			<P>UTF8</P>
		</TD>
		<TD WIDTH=519>
			<P>Unicode string</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128>
			<P>elements</P>
		</TD>
		<TD WIDTH=519>
			<P>Embedded EBML elements</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128>
			<P>binary</P>
		</TD>
		<TD WIDTH=519>
			<P>Block of binary data</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128>
			<P>MD5</P>
		</TD>
		<TD WIDTH=519>
			<P>16 byte (128 bit) MD5 sum</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128>
			<P>CRC32</P>
		</TD>
		<TD WIDTH=519>
			<P>4 byte integer CRC-32 signature</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0in; font-style: normal; font-weight: medium">
<BR>
</P>
<H2 CLASS="western"><A NAME="6.4.CRC32 checksums|outline"></A>6.4CRC32
checksums</H2>
<P><SPAN STYLE="font-weight: medium">CRC32 checksums can be
optionally used for the CramInfo and FileInfo chunks.  It is
recommended that they are present in order to catch corruption of
information, although decoders should attempt to continue even if the
CRC fails.  The compressed audio/binary data itself is protected by
MD5 checksums.  The file relocation tables use an Adler-32 checksum
in the case of </SPAN><B>zlib</B><SPAN STYLE="font-weight: medium">
(bzlib has its own CRC32 built in).</SPAN></P>
<H2 CLASS="western"><A NAME="5.5.Errata|outline"></A><A NAME="5.5.Errata|outline"></A><A NAME="5.5.Errata|outline"></A><A NAME="6.5.Errata|outline"></A>
6.5Errata</H2>
<P STYLE="font-weight: medium">Versions <B>0x81 </B><SPAN STYLE="font-weight: medium">through
</SPAN><B>0x83 </B><SPAN STYLE="font-weight: medium">of </SPAN>the
CRAM format were broken.  All integer field values were stored as
variable length encoded integers (what is used for the CRAM chunk IDs
and sizes).  This was not only unnecessary (integer length can be
inferred from chunk size) but also contrary to EBML spec.  Since CRAM
was not yet widely (if at all) used, it was decided to break
backwards compatibility and set things right.  Integer fields are now
just stored as regular big endian values.</P>
<P STYLE="font-weight: medium">Older CRAM files can be detected by
the falsely written EBMLVersion chunk (should be the first chunk
within the top EBML chunk).  The value 0x81 (129 decimal) will be
found, which corresponds to a variable length encoded value of 1. 
The correct value is just a single byte containing 0x01.</P>
<H1 CLASS="western"><A NAME="5.CRAM format reference|outline"></A><A NAME="5.CRAM format reference|outline"></A><A NAME="5.CRAM format reference|outline"></A><A NAME="7.CRAM format reference|outline"></A>
7CRAM format reference</H1>
<UL>
	<LI><P STYLE="margin-bottom: 0in; font-weight: medium">First column
	defines if field is required ('*' indicates requirement).</P>
	<LI><P STYLE="margin-bottom: 0in; font-weight: medium">(XX) defines
	a hex byte value</P>
	<LI><P STYLE="margin-bottom: 0in"><SPAN STYLE="font-weight: medium">(</SPAN><B>vN</B><SPAN STYLE="font-weight: medium">)
	indicates a specific CRAM format version requirement.</SPAN></P>
	<LI><P STYLE="margin-bottom: 0in"><SPAN STYLE="font-weight: medium">Refer
	to </SPAN><A HREF="#4.3.Data types|outline"></A><A HREF="#4.3.Data types|outline"></A><A HREF="#4.3.Data types|outline"><SPAN STYLE="font-weight: medium">Data
	Types</SPAN></A><A HREF="#4.3.Data types|outline"></A><A HREF="#4.3.Data types|outline"></A><SPAN STYLE="font-weight: medium">
	for details on the data types in the following tables.</SPAN></P>
	<LI><P STYLE="margin-bottom: 0in; font-weight: medium">&ldquo;[]&rdquo;
	is used to indicate one or more values (an array)</P>
	<LI><P STYLE="margin-bottom: 0in; font-weight: medium">'|' is used
	to illustrate the embedded tree structure of the EBML chunks</P>
	<LI><P STYLE="margin-bottom: 0in; background: #ffcc99; font-weight: medium">
	This color indicates chunks which contain embedded chunks</P>
	<LI><P STYLE="margin-bottom: 0in; background: #ccffff; font-weight: medium">
	This color indicates the chunk is further defined in another table</P>
</UL>
<H2 CLASS="western"><A NAME="7.1.CRAM file format|outline"></A>7.1CRAM
file format</H2>
<TABLE WIDTH=665 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=10>
	<COL WIDTH=166>
	<COL WIDTH=120>
	<COL WIDTH=85>
	<COL WIDTH=242>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P><BR>
			</P>
		</TD>
		<TD WIDTH=166>
			<P><B>Field Name</B></P>
		</TD>
		<TD WIDTH=120>
			<P><B>EBML ID</B></P>
		</TD>
		<TD WIDTH=85>
			<P><B>Data Type</B></P>
		</TD>
		<TD WIDTH=242>
			<P><B>Description</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P>*</P>
		</TD>
		<TD WIDTH=166 BGCOLOR="#ffcc99">
			<P STYLE="background: transparent"><FONT COLOR="#000000"><U>EBML
			chunk</U></FONT></P>
		</TD>
		<TD WIDTH=120>
			<P>(1A)(45)(DF)(A3)</P>
		</TD>
		<TD WIDTH=85>
			<P>elements</P>
		</TD>
		<TD WIDTH=242>
			<P>EBML document chunk.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P>*</P>
		</TD>
		<TD WIDTH=166>
			<P><FONT COLOR="#000000"> | DocType</FONT></P>
		</TD>
		<TD WIDTH=120>
			<P>(42)(82)</P>
		</TD>
		<TD WIDTH=85>
			<P>string</P>
		</TD>
		<TD WIDTH=242>
			<P>&ldquo;CRAM&rdquo;, &ldquo;CRAML&rdquo;, or &ldquo;CRAMC</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P>*</P>
		</TD>
		<TD WIDTH=166>
			<P><FONT COLOR="#000000"> | DocTypeVersion</FONT></P>
		</TD>
		<TD WIDTH=120>
			<P>(42)(87)</P>
		</TD>
		<TD WIDTH=85>
			<P>uint</P>
		</TD>
		<TD WIDTH=242>
			<P>CRAM format version = 1.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P>*</P>
		</TD>
		<TD WIDTH=166>
			<P><FONT COLOR="#000000"> | DocTypeReadVersion</FONT></P>
		</TD>
		<TD WIDTH=120>
			<P>(42)(85)</P>
		</TD>
		<TD WIDTH=85>
			<P>uint</P>
		</TD>
		<TD WIDTH=242>
			<P>CRAM read version required = 1.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P>*</P>
		</TD>
		<TD WIDTH=166 BGCOLOR="#ffcc99">
			<P><FONT COLOR="#000000"><U>CramInfo chunk</U></FONT></P>
		</TD>
		<TD WIDTH=120>
			<P>(41)(80)</P>
		</TD>
		<TD WIDTH=85>
			<P>elements</P>
		</TD>
		<TD WIDTH=242>
			<P>Information for entire CRAM file</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P>*</P>
		</TD>
		<TD WIDTH=166>
			<P><FONT COLOR="#000000"> | Software</FONT></P>
		</TD>
		<TD WIDTH=120>
			<P>(61)(3C)</P>
		</TD>
		<TD WIDTH=85>
			<P>string</P>
		</TD>
		<TD WIDTH=242>
			<P>Software name and version</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P><BR>
			</P>
		</TD>
		<TD WIDTH=166>
			<P><FONT COLOR="#000000"> | Flags</FONT></P>
		</TD>
		<TD WIDTH=120>
			<P>(61)(31)</P>
		</TD>
		<TD WIDTH=85>
			<P>uint</P>
		</TD>
		<TD WIDTH=242>
			<P><A HREF="#6.1.Flags|outline">See Flags</A></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P><BR>
			</P>
		</TD>
		<TD WIDTH=166>
			<P><FONT COLOR="#000000"> | Comment</FONT></P>
		</TD>
		<TD WIDTH=120>
			<P>(61)(45)</P>
		</TD>
		<TD WIDTH=85>
			<P>UTF8</P>
		</TD>
		<TD WIDTH=242>
			<P>Comment with '\n' newline chars.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P><BR>
			</P>
		</TD>
		<TD WIDTH=166>
			<P STYLE="background: transparent; font-weight: medium; text-decoration: none">
			 | CRC-32</P>
		</TD>
		<TD WIDTH=120>
			<P>(BF)</P>
		</TD>
		<TD WIDTH=85>
			<P>CRC32</P>
		</TD>
		<TD WIDTH=242>
			<P>Checksum of CramInfo data</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P>*</P>
		</TD>
		<TD WIDTH=166 BGCOLOR="#ccffff">
			<P STYLE="background: transparent; font-weight: medium; text-decoration: none">
			<B>FileChunks</B>[]</P>
		</TD>
		<TD WIDTH=120>
			<P>(41)(81)</P>
		</TD>
		<TD WIDTH=85>
			<P>elements</P>
		</TD>
		<TD WIDTH=242>
			<P>One or more file chunks</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=10>
			<P>*</P>
		</TD>
		<TD WIDTH=166>
			<P>FileEnd</P>
		</TD>
		<TD WIDTH=120>
			<P>(41)(8C)</P>
		</TD>
		<TD WIDTH=85>
			<P>empty</P>
		</TD>
		<TD WIDTH=242>
			<P>End of file chunk.</P>
		</TD>
	</TR>
</TABLE>
<H2 CLASS="western"><A NAME="5.1.FileChunk|outline"></A><A NAME="5.1.FileChunk|outline"></A><A NAME="5.1.FileChunk|outline"></A><A NAME="7.2.FileChunk|outline"></A>
7.2FileChunk</H2>
<TABLE WIDTH=665 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=10>
	<COL WIDTH=187>
	<COL WIDTH=99>
	<COL WIDTH=85>
	<COL WIDTH=242>
	<THEAD>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P><B>Field Name</B></P>
			</TD>
			<TD WIDTH=99>
				<P><B>EBML ID</B></P>
			</TD>
			<TD WIDTH=85>
				<P><B>Data Type</B></P>
			</TD>
			<TD WIDTH=242>
				<P><B>Description</B></P>
			</TD>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=187 BGCOLOR="#ffcc99">
				<P STYLE="background: transparent; font-weight: medium"><U>FileChunk</U></P>
			</TD>
			<TD WIDTH=99>
				<P>(41)(81)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Defines a file in a CRAM archive.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=187 BGCOLOR="#ffcc99">
				<P> | <U>FileInfo</U></P>
			</TD>
			<TD WIDTH=99>
				<P>(41)(84)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>File information chunk</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=187>
				<P> | | FileSize</P>
			</TD>
			<TD WIDTH=99>
				<P>(61)(53)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Original file size.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=187>
				<P> | | FileName</P>
			</TD>
			<TD WIDTH=99>
				<P>(61)(57)</P>
			</TD>
			<TD WIDTH=85>
				<P>UTF8</P>
			</TD>
			<TD WIDTH=242>
				<P>Relative path delimited by '/'s.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | | FileDate</P>
			</TD>
			<TD WIDTH=99>
				<P>(61)(5C)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Unix 32 bit timestamp.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | | Flags</P>
			</TD>
			<TD WIDTH=99>
				<P>(61)(31)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P><A HREF="#6.1.Flags|outline">See Flags</A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | | CRC-32</P>
			</TD>
			<TD WIDTH=99>
				<P>(BF)</P>
			</TD>
			<TD WIDTH=85>
				<P>CRC32</P>
			</TD>
			<TD WIDTH=242>
				<P>Checksum of FileInfo data</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=187 BGCOLOR="#ffcc99">
				<P> | <U>F</U><U><SPAN STYLE="font-weight: medium">ileData</SPAN></U></P>
			</TD>
			<TD WIDTH=99>
				<P>(41)(95)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Stores compressed audio and binary</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | | BinaryChunk</P>
			</TD>
			<TD WIDTH=99>
				<P>(C2)</P>
			</TD>
			<TD WIDTH=85>
				<P>binary</P>
			</TD>
			<TD WIDTH=242>
				<P>Compressed binary chunk</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | | FlacChunk</P>
			</TD>
			<TD WIDTH=99>
				<P>(D3)</P>
			</TD>
			<TD WIDTH=85>
				<P>binary</P>
			</TD>
			<TD WIDTH=242>
				<P>Compressed FLAC audio chunk</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | | WavPackChunk</P>
			</TD>
			<TD WIDTH=99>
				<P>(D9)</P>
			</TD>
			<TD WIDTH=85>
				<P>binary</P>
			</TD>
			<TD WIDTH=242>
				<P>Compressed WavPack audio chunk</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | | VerbatimChunk</P>
			</TD>
			<TD WIDTH=99>
				<P>(C7)</P>
			</TD>
			<TD WIDTH=85>
				<P>binary</P>
			</TD>
			<TD WIDTH=242>
				<P>Verbatim uncompressed data</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | | SetAudioEntry</P>
			</TD>
			<TD WIDTH=99>
				<P>(C4)</P>
			</TD>
			<TD WIDTH=85>
				<P>int</P>
			</TD>
			<TD WIDTH=242>
				<P>See <A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline">Grouping
				audio segments</A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=187 BGCOLOR="#ccffff">
				<P> | <U><B>RelocTable</B></U></P>
			</TD>
			<TD WIDTH=99>
				<P>(41)(A5)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Relocation table (compressed)</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | RelocTableChkSum</P>
			</TD>
			<TD WIDTH=99>
				<P>(41)(A9)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Adler32 RelocTable checksum (zlib only)</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | FileMD5</P>
			</TD>
			<TD WIDTH=99>
				<P>(41)(AA)</P>
			</TD>
			<TD WIDTH=85>
				<P>MD5</P>
			</TD>
			<TD WIDTH=242>
				<P>MD5 of original file</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=187>
				<P> | BinaryMD5</P>
			</TD>
			<TD WIDTH=99>
				<P>(41)(AC)</P>
			</TD>
			<TD WIDTH=85>
				<P>MD5</P>
			</TD>
			<TD WIDTH=242>
				<P>MD5 sum of original binary data</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<H2 CLASS="western"><A NAME="5.2.Relocation table|outline"></A><A NAME="5.2.Relocation table|outline"></A><A NAME="5.2.Relocation table|outline"></A><A NAME="7.3.Relocation table|outline"></A>
7.3Relocation table</H2>
<TABLE WIDTH=665 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=10>
	<COL WIDTH=166>
	<COL WIDTH=120>
	<COL WIDTH=85>
	<COL WIDTH=242>
	<THEAD>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P><B>Field Name</B></P>
			</TD>
			<TD WIDTH=120>
				<P><B>EBML ID</B></P>
			</TD>
			<TD WIDTH=85>
				<P><B>Data Type</B></P>
			</TD>
			<TD WIDTH=242>
				<P><B>Description</B></P>
			</TD>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166 BGCOLOR="#ffcc99">
				<P STYLE="font-weight: medium"><U>RelocTable</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(A5)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Relocation table (compressed)</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166 BGCOLOR="#ffcc99">
				<P><SPAN STYLE="text-decoration: none"> | </SPAN><U>BinaryChunk</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(C2)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Binary data relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P> | | RawSize</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(63)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Uncompressed size in bytes</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166 BGCOLOR="#ffcc99">
				<P> | <U>FlacChunk</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(D3)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>FLAC audio relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P> | | RawSize</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(63)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Uncompressed size in bytes</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | Flags</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(31)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P><A HREF="#6.1.Flags|outline">See Flags</A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | NextAudioEntry</P>
			</TD>
			<TD WIDTH=120>
				<P>(C5)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>See <A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline">Grouping
				audio segments</A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166 BGCOLOR="#ffcc99">
				<P><SPAN STYLE="text-decoration: none"> | </SPAN><U>FlacSplitChunk</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(D7)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>FLAC split audio relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P> | | RawSize</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(63)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Size of 1<SUP>st</SUP> split segment in bytes</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | Flags</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(31)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P><A HREF="#6.1.Flags|outline">See Flags</A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10 HEIGHT=16>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | NextAudioEntry</P>
			</TD>
			<TD WIDTH=120>
				<P>(C5)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>See <A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline">Grouping
				audio segments</A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10 HEIGHT=16>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | ChanCount</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(65)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint 
				</P>
			</TD>
			<TD WIDTH=242>
				<P>Channel count (default = 2)</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | SampleSplit</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(69)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P><A HREF="#6.6.3.FlacSplitChunk and WavPackSplitChunk|outline">Sample
				width split</A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | Offsets</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(66)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint[]</P>
			</TD>
			<TD WIDTH=242>
				<P>Offset of each audio chunk.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166 BGCOLOR="#ffcc99">
				<P> | <U>WavPackChunk</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(D9)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>WavPack audio relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P> | | RawSize</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(63)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Uncompressed size in bytes</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | Flags</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(31)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P><A HREF="#6.1.Flags|outline">See Flags</A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | NextAudioEntry</P>
			</TD>
			<TD WIDTH=120>
				<P>(C5)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>See <A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline">Grouping
				audio segments</A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | SmoothLoop</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(73)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint[2]</P>
			</TD>
			<TD WIDTH=242>
				<P>LoopStart, LoopSize</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166 BGCOLOR="#ffcc99">
				<P> | <U>WavPackSplitChunk</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(DD)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>WavPack split audio relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P> | | RawSize</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(63)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Size of 1<SUP>st</SUP> split segment in bytes</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | Flags</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(31)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P><A HREF="#6.1.Flags|outline">See Flags</A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | NextAudioEntry</P>
			</TD>
			<TD WIDTH=120>
				<P>(C5)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>See <A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline">Grouping
				audio segments</A><A HREF="#6.5.Grouping audio segments|outline"></A><A HREF="#6.5.Grouping audio segments|outline"></A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | ChanCount</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(65)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Channel count (default = 2, stereo)</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10 HEIGHT=16>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | SampleSplit</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(69)</P>
			</TD>
			<TD WIDTH=85>
				<P STYLE="text-decoration: none">uint</P>
			</TD>
			<TD WIDTH=242>
				<P><A HREF="#6.6.3.FlacSplitChunk and WavPackSplitChunk|outline">Sample
				width split</A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | Offsets</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(66)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint[]</P>
			</TD>
			<TD WIDTH=242>
				<P>Offset of each audio chunk</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P> | | SmoothLoop</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(73)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint[2]</P>
			</TD>
			<TD WIDTH=242>
				<P>LoopStart, LoopSize</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<PRE STYLE="font-weight: medium"></PRE><H2 CLASS="western">
<A NAME="7.4.Chunks listed by EBML ID|outline"></A>7.4Chunks listed
by EBML ID</H2>
<P>Re-listing of all chunks, sorted by EBML ID.</P>
<TABLE WIDTH=665 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=10>
	<COL WIDTH=166>
	<COL WIDTH=120>
	<COL WIDTH=85>
	<COL WIDTH=242>
	<THEAD>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P><B>Field Name</B></P>
			</TD>
			<TD WIDTH=120>
				<P><B>EBML ID</B></P>
			</TD>
			<TD WIDTH=85>
				<P><B>Data Type</B></P>
			</TD>
			<TD WIDTH=242>
				<P><B>Description</B></P>
			</TD>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P STYLE="background: transparent"><FONT COLOR="#000000"><U>EBML
				chunk</U></FONT></P>
			</TD>
			<TD WIDTH=120>
				<P>(1A)(45)(DF)(A3)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>EBML document chunk.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P><FONT COLOR="#000000"><U>CramInfo chunk</U></FONT></P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(80)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Information for entire CRAM file</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P STYLE="background: transparent; font-weight: medium"><U>FileChunk</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(81)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Defines a file in a CRAM archive.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10 HEIGHT=16>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P><U>FileInfo</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(84)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>File information chunk</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10 HEIGHT=16>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P>FileEnd</P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(8C)</P>
			</TD>
			<TD WIDTH=85>
				<P>empty</P>
			</TD>
			<TD WIDTH=242>
				<P>End of file chunk.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P><U>F<SPAN STYLE="font-weight: medium">ileData</SPAN></U></P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(95)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Stores compressed audio and binary</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P STYLE="font-weight: medium; text-decoration: none">RelocTable</P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(A5)</P>
			</TD>
			<TD WIDTH=85>
				<P>elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Relocation table (compressed)</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>RelocTableChkSum</P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(A9)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>RelocTable checksum (zlib only)</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>FileMD5</P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(AA)</P>
			</TD>
			<TD WIDTH=85>
				<P>MD5</P>
			</TD>
			<TD WIDTH=242>
				<P>MD5 of original file</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>BinaryMD5</P>
			</TD>
			<TD WIDTH=120>
				<P>(41)(AC)</P>
			</TD>
			<TD WIDTH=85>
				<P>MD5</P>
			</TD>
			<TD WIDTH=242>
				<P>MD5 sum of original binary data</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P><FONT COLOR="#000000">DocType</FONT></P>
			</TD>
			<TD WIDTH=120>
				<P>(42)(82)</P>
			</TD>
			<TD WIDTH=85>
				<P>string</P>
			</TD>
			<TD WIDTH=242>
				<P>&ldquo;CRAM&rdquo;, &ldquo;CRAML&rdquo;, or &ldquo;CRAMC&rdquo;</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P><FONT COLOR="#000000">DocTypeReadVersion</FONT></P>
			</TD>
			<TD WIDTH=120>
				<P>(42)(85)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>CRAM read version required</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10 HEIGHT=16>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P><FONT COLOR="#000000">DocTypeVersion</FONT></P>
			</TD>
			<TD WIDTH=120>
				<P>(42)(87)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>CRAM format version</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P><FONT COLOR="#000000">Flags</FONT></P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(31)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P><A HREF="#6.1.Flags|outline">See Flags</A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P><FONT COLOR="#000000">Software</FONT></P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(3C)</P>
			</TD>
			<TD WIDTH=85>
				<P>string</P>
			</TD>
			<TD WIDTH=242>
				<P>Software name and version</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P><FONT COLOR="#000000">Comment</FONT></P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(45)</P>
			</TD>
			<TD WIDTH=85>
				<P>UTF8</P>
			</TD>
			<TD WIDTH=242>
				<P>Comment with '\n' newline chars.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P>FileSize</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(53)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Original file size.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P>FileName</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(57)</P>
			</TD>
			<TD WIDTH=85>
				<P>UTF8</P>
			</TD>
			<TD WIDTH=242>
				<P>Relative path delimited by '/'s.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>FileDate</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(5C)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Unix 32 bit timestamp.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P>*</P>
			</TD>
			<TD WIDTH=166>
				<P>RawSize</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(63)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Uncompressed size in bytes</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>ChanCount</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(65)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Channel count (default = 2, stereo)</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>Offsets</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(66)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint[]</P>
			</TD>
			<TD WIDTH=242>
				<P>Offset of each split segment</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>SampleSplit</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(69)</P>
			</TD>
			<TD WIDTH=85>
				<P STYLE="text-decoration: none">uint</P>
			</TD>
			<TD WIDTH=242>
				<P><A HREF="#6.6.3.FlacSplitChunk and WavPackSplitChunk|outline">Sample
				width split</A></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>SmoothLoop</P>
			</TD>
			<TD WIDTH=120>
				<P>(61)(73)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint[2]</P>
			</TD>
			<TD WIDTH=242>
				<P>LoopStart, LoopSize</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P STYLE="background: transparent; font-weight: medium; text-decoration: none">
				CRC-32</P>
			</TD>
			<TD WIDTH=120>
				<P>(BF)</P>
			</TD>
			<TD WIDTH=85>
				<P>CRC32</P>
			</TD>
			<TD WIDTH=242>
				<P>A CRC-32 checksum of chunk data</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P><U>BinaryChunk</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(C2)</P>
			</TD>
			<TD WIDTH=85>
				<P>bin/elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Binary data or relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>SetAudioEntry</P>
			</TD>
			<TD WIDTH=120>
				<P>(C4)</P>
			</TD>
			<TD WIDTH=85>
				<P>uint</P>
			</TD>
			<TD WIDTH=242>
				<P>Offset current audio relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P STYLE="font-weight: medium">NextAudioEntry</P>
			</TD>
			<TD WIDTH=120>
				<P>(C5)</P>
			</TD>
			<TD WIDTH=85>
				<P>int</P>
			</TD>
			<TD WIDTH=242>
				<P>Offset to next relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>VerbatimChunk</P>
			</TD>
			<TD WIDTH=120>
				<P>(C7)</P>
			</TD>
			<TD WIDTH=85>
				<P>bin/elements</P>
			</TD>
			<TD WIDTH=242>
				<P>Verbatim data or relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P><U>FlacChunk</U></P>
			</TD>
			<TD WIDTH=120>
				<P>(D3)</P>
			</TD>
			<TD WIDTH=85>
				<P>bin/elements</P>
			</TD>
			<TD WIDTH=242>
				<P>FLAC data or relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>FlacSplitChunk</P>
			</TD>
			<TD WIDTH=120>
				<P>(D7)</P>
			</TD>
			<TD WIDTH=85>
				<P>bin/elements</P>
			</TD>
			<TD WIDTH=242>
				<P>FLAC split relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>WavPackChunk</P>
			</TD>
			<TD WIDTH=120>
				<P>(D9)</P>
			</TD>
			<TD WIDTH=85>
				<P>bin/elements</P>
			</TD>
			<TD WIDTH=242>
				<P>WavPack data or relocation entry</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=10>
				<P><BR>
				</P>
			</TD>
			<TD WIDTH=166>
				<P>WavPackSplitChunk</P>
			</TD>
			<TD WIDTH=120>
				<P>(DD)</P>
			</TD>
			<TD WIDTH=85>
				<P>bin/elements</P>
			</TD>
			<TD WIDTH=242>
				<P>WavPack split relocation entry</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<H1 CLASS="western"><A NAME="8.Cram format description|outline"></A>8Cram
format description</H1>
<P>A CRAM file consists of an <A HREF="#5.CRAM format reference|outline"></A><A HREF="#5.CRAM format reference|outline"></A><A HREF="#5.CRAM format reference|outline">EBML
chunk</A><A HREF="#5.CRAM format reference|outline"></A><A HREF="#5.CRAM format reference|outline"></A>,
optional EBMLInfo chunk, one or more <A HREF="#5.1.FileChunk|outline"></A><A HREF="#5.1.FileChunk|outline"></A><A HREF="#5.1.FileChunk|outline">FileChunks</A><A HREF="#5.1.FileChunk|outline"></A><A HREF="#5.1.FileChunk|outline"></A>
and a FileEnd terminator chunk.</P>
<H2 CLASS="western"><A NAME="6.3.CRAM format version history|outline"></A><A NAME="6.3.CRAM format version history|outline"></A><A NAME="6.3.CRAM format version history|outline"></A><A NAME="8.1.CRAM format version history|outline"></A>
8.1CRAM format version history</H2>
<P>The CRAM format version is updated whenever any changes occur to
the defined format.  If any new features are used in a CRAM file that
would cause the parser to break or make it impossible for previous
decoder versions to reconstruct the compressed files the appropriate
format version required should be written.  Note that the lowest
compatible read version should be used in all cases, so only the use
of new features should warrant an increment in the stored read
version.</P>
<P><B>NOTE:</B><SPAN STYLE="font-weight: medium"> Versions </SPAN><B>v0x81
</B><SPAN STYLE="font-weight: medium">through </SPAN><B>v0x83</B><SPAN STYLE="font-weight: medium">
are considered pre-formats.  They were broken in regards to </SPAN><A HREF="#5.5.Errata|outline"></A><A HREF="#5.5.Errata|outline"></A><A HREF="#5.5.Errata|outline"><SPAN STYLE="font-weight: medium">storing
integer fields</SPAN></A><A HREF="#5.5.Errata|outline"></A><A HREF="#5.5.Errata|outline"></A><SPAN STYLE="font-weight: medium">
(including the DocTypeVersion itself, which is indicated by the 0x81,
0x82 and 0x83).  For this reason, and the fact that backwards
compatibility was broken, the version was restarted at version 1. 
This shouldn't be much of an issue though, since CRAM was not yet in
wide use.</SPAN></P>
<UL>
	<LI><P><B>v1</B> &ndash; 2007-04-29</P>
	<UL>
		<LI><P>Backwards compatibility completely broken</P>
		<LI><P>Integer fields are now stored non UTF encoded (wasn't
		necessary to begin with)</P>
		<LI><P>Added AudioEntryOfs and NextEntryOfs to allow multiple audio
		segments to be encoded together</P>
		<LI><P>Added WavPack support, including hybrid lossy/lossless mode</P>
		<LI><P>Added bzip2 support</P>
		<LI><P>Added Verbatim data chunk</P>
		<LI><P>Split chunk types no longer used in FileData chunk</P>
		<LI><P>Removed AudioMD5 and added FileMD5 (MD5 on entire original
		file).  MD5 now requires a separate pass (needed anyways due to
		sample grouping).</P>
	</UL>
	<LI><P><B>v0x83</B> &ndash; 2006-07-31</P>
	<UL>
		<LI><P>sampleSplit chunk type added to support 24 bit SoundFont
		files</P>
	</UL>
	<LI><P><B>v0x82</B> - 2005-03-20 - completely backwards compatible
	with v1</P>
	<UL>
		<LI><P>Added Software and Comment fields to CRAM header</P>
		<LI><P>Future defined chunks should also be expected at the
		fileChunk level (backwards compatibility with format v1 will be
		broken if a new chunk is added at this level)</P>
	</UL>
	<LI><P><B>v0x81</B> - First version</P>
</UL>
<H2 CLASS="western"><A NAME="8.2.EBML chunk|outline"></A>8.2EBML
chunk</H2>
<P>The <B>EBML chunk</B> defines the file as an EBML file with one of
3 document types: &ldquo;CRAM&rdquo;, &ldquo;CRAML&rdquo; or &ldquo;CRAMC&rdquo;
for a lossless, lossy and correction CRAM file types respectively. 
In addition this chunk defines the <A HREF="#6.3.CRAM format version history|outline"></A><A HREF="#6.3.CRAM format version history|outline"></A><A HREF="#6.3.CRAM format version history|outline">CRAM
format version</A><A HREF="#6.3.CRAM format version history|outline"></A><A HREF="#6.3.CRAM format version history|outline"></A>
of the encoder used to write the file and the required format version
to read the file.  All fields in the EBML chunk should be in the same
order indicated and the EBML chunk size value should always be 1 byte
in length.  This is to aid in identifying CRAM files.  The
EBMLVersion and EBMLReadVersion chunks which are part of the EBML
standard both default to a value of 1.  This is unlikely to change
for the CRAM format, so they have been omitted from the standard.  If
for some reason a newer version of EBML is used (highly unlikely), it
would be part of a new CRAM version (covered by DocTypeReadVersion).</P>
<H2 CLASS="western"><A NAME="8.3.CramInfo chunk|outline"></A>8.3CramInfo
chunk</H2>
<P>Required chunk containing data which applies to the entire CRAM
archive.  Currently includes 3 fields: Software, Flags, and Comment. 
The Software field is required and is a UTF-8 string which describes
the software used to write the CRAM file (example: &ldquo;libInstPatch
1.0.0&rdquo;),. it should not exceed 64 bytes.  The comment field is
an optional UTF-8 encoded string with '\n' line terminators.  Size of
Comment string should be limited to a max of 4096 bytes.  When
displaying this field, a newline should be added if necessary to the
end.</P>
<P><B>Example comment</B></P>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P>Downloaded from Resonance Instrument Database<SPAN STYLE="text-decoration: none"><B>\n</B></SPAN></P>
			<P><A HREF="http://sounds.resonance.org/">http://sounds.resonance.org</A></P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>
<P>The Flags field is optional and defines the global flags value for
the CRAM archive.  An optional CRC-32 field may be present and
defines the CRC-32 checksum value for all other data (besides the CRC
chunk and value itself) in the CramInfo chunk.  CRAM parsers should
issue a warning if this CRC fails, but should attempt to continue.</P>
<H2 CLASS="western"><A NAME="6.2.Flags|outline"></A><A NAME="6.2.Flags|outline"></A><A NAME="6.2.Flags|outline"></A><A NAME="6.1.Flags|outline"></A><A NAME="6.1.Flags|outline"></A><A NAME="6.1.Flags|outline"></A><A NAME="6.1.Flags|outline"></A><A NAME="6.1.Flags|outline"></A><A NAME="6.1.Flags|outline"></A><A NAME="6.1.Flags|outline"></A><A NAME="8.4.Flags|outline"></A>
8.4Flags</H2>
<P>The flags field is used throughout the CRAM format.  Not all flags
are valid at every level of the format though.  Note that the binary
compressor type is actually a 2 bit field defining up to 4 different
binary compressor types (only 2 used currently).  The given flag may
be used at all levels where &ldquo;Flags&rdquo; is defined unless
otherwise noted.  A Flags chunk at a more embedded level overrides
that of a higher level.</P>
<P><BR><BR>
</P>
<TABLE WIDTH=665 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=148>
	<COL WIDTH=165>
	<COL WIDTH=326>
	<TR VALIGN=TOP>
		<TD WIDTH=148>
			<P><B>Flag Name</B></P>
		</TD>
		<TD WIDTH=165>
			<P><B>Value</B></P>
		</TD>
		<TD WIDTH=326>
			<P><B>Description</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148>
			<P>Binary compressor</P>
		</TD>
		<TD WIDTH=165>
			<P>0x03 mask (2 bit enum)</P>
		</TD>
		<TD WIDTH=326>
			<P>Binary compressor used</P>
			<P>0 = <B>zlib</B>, 1 = <B>bzlib</B><SPAN STYLE="font-weight: medium">
			(</SPAN><B>v4</B><SPAN STYLE="font-weight: medium">), </SPAN>2/3 =
			<B>reserved</B></P>
			<P>Only valid in EBML and fileChunk levels, this field is ignored
			at other levels.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148>
			<P>Big endian audio</P>
		</TD>
		<TD WIDTH=165>
			<P>0x04</P>
		</TD>
		<TD WIDTH=326>
			<P>If set to 1, indicates that audio is big endian.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148>
			<P>Unsigned audio</P>
		</TD>
		<TD WIDTH=165>
			<P>0x08</P>
		</TD>
		<TD WIDTH=326>
			<P>If set to 1, indicates that audio is unsigned.</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<H2 CLASS="western"><A NAME="8.5.FileChunk|outline"></A>8.5FileChunk</H2>
<P>The <B>FileChunk</B><SPAN STYLE="font-weight: medium"> defines a
single file in a CRAM archive.  It contains, in order, the FileInfo,</SPAN>
FileData, <A HREF="#5.2.Relocation table|outline"></A><A HREF="#5.2.Relocation table|outline"></A><A HREF="#5.2.Relocation table|outline">RelocTable</A><A HREF="#5.2.Relocation table|outline"></A><A HREF="#5.2.Relocation table|outline"></A>,
RelocTableChkSum, FileMD5 and BinaryMD5 chunks.</P>
<P><SPAN STYLE="font-weight: medium">The FileInfo chunk contains, in
order, the required FileSize and FileName chunks and optional
FileDate, </SPAN><A HREF="#6.2.Flags|outline"></A><A HREF="#6.2.Flags|outline"></A><A HREF="#6.2.Flags|outline"><SPAN STYLE="font-weight: medium">Flags</SPAN></A><A HREF="#6.2.Flags|outline"></A><A HREF="#6.2.Flags|outline"></A>
and CRC-32 checksum.  The FileSize field stores the original file
size.  FileName contains a UTF-8 encoded file name which can include
a relative '/' delimited path for storing paths in the archive. 
Parsers should issue a warning if the CRC-32 of the FileInfo fails,
but continue anyways.</P>
<P>The FileData chunk contains zero or more compressed binary,
uncompressed binary and audio chunks.  Types of binary chunks
include: BinaryChunk and VerbatimChunk.  The former is for
compressing blocks of binary data (with bzlib or zlib) and the latter
is for just storing raw data as is (used for example, if it is
already compressed).</P>
<P>The types of audio chunks include: FlacChunk and WavPackChunk.</P>
<P>The FileMD5 chunk stores the 16 byte MD5 sum of the original file
(binary and audio).  The BinaryMD5 is the MD5 sum of the original
uncompressed binary data concatenated together.  This allows for data
integrity checks of only the binary data in the event that the audio
data will be streamed (removes the need to reconstruct the whole
file) or in the case of a CRAML file where the audio data is lossy.</P>
<H2 CLASS="western"><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="6.5.Grouping audio segments|outline"></A><A NAME="7.5.Grouping audio segments|outline"></A><A NAME="7.5.Grouping audio segments|outline"></A><A NAME="7.5.Grouping audio segments|outline"></A><A NAME="8.6.Grouping audio segments|outline"></A>
8.6Grouping audio segments</H2>
<P>Two new chunk types, SetAudioEntry and NextAudioEntry, were added
to allow for multiple audio segments of the same format to be
compressed as if they were a single segment (in one compressed audio
chunk).  This was done in the interest of minimizing protocol
overhead.</P>
<P>The <B>SetAudioEntry</B> chunk can be used before a compressed
audio chunk in <B>FileData</B> to indicate that the corresponding
relocation entry is at a given offset from the next audio entry. 
Normally the next audio related relocation entry would be used to
locate the position where the data belongs in the file, but if for a
example a SetAudioEntry is found and has a value of 2, then 2 audio
relocation entries would be skipped when selecting the matching
relocation entry.  This value is signed, so that negative offsets can
be specified.</P>
<P>The <B>NextAudioEntry</B><SPAN STYLE="font-weight: medium"> chunk
can be used within audio relocation entries in the relocation table. 
It indicates an offset to the next audio relocation entry in the
chain of grouped audio segments.  The offset value is unsigned and in
reference to the next audio entry.</SPAN></P>
<P STYLE="font-weight: medium">Note that both offset values are for
audio entries only and binary entries are not counted (BinaryChunk
and VerbatimChunk).</P>
<H2 CLASS="western"><A NAME="8.7.Relocation table|outline"></A>8.7Relocation
table</H2>
<P>The relocation table defines all the segments of audio and binary
information so that they can be reconstructed into the original file.
 The entire RelocTable chunk is compressed using the selected binary
compressor (zlib or bzlib).  In other words, the RelocTable chunk
itself is a block of binary data, the contents of which are the
compressed EBML chunks of the relocation table.</P>
<P>The relocation table consists of one or more sub chunks from the
list: BinaryChunk, FlacChunk, FlacSplitChunk, WavPackChunk,
WavPackSplitChunk and NextAudioEntry which are described below.</P>
<H3 CLASS="western"><A NAME="8.7.1.BinaryChunk|outline"></A>8.7.1BinaryChunk</H3>
<P>Indicates a binary segment in the original file and contains only
a RawSize field which stores the size of the uncompressed binary
data.</P>
<H3 CLASS="western"><A NAME="8.7.2.FlacChunk and WavPackChunk|outline"></A>
8.7.2FlacChunk and WavPackChunk</H3>
<P>Indicates an audio segment in the original file.  It contains a
RawSize field which stores the original size in bytes of the audio
and an optional Flags field which can be used to indicate a different
little/big endian or signed/unsigned options.  The Flags field is
only specified here if the endian and/or sign of the audio format
changes within the same file, which is unlikely.  These flags can
also be set at the FileChunk level, defining the defaults for the
entire file or CRAMInfo chunk level for the entire CRAM archive.</P>
<H3 CLASS="western"><A NAME="6.6.3.FlacSplitChunk and WavPackSplitChunk|outline"></A><A NAME="6.6.3.FlacSplitChunk and WavPackSplitChunk|outline"></A><A NAME="6.6.3.FlacSplitChunk and WavPackSplitChunk|outline"></A><A NAME="8.7.3.FlacSplitChunk and WavPackSplitChunk|outline"></A>
8.7.3FlacSplitChunk and WavPackSplitChunk</H3>
<P>Indicates an audio segment in the original file which is split by
channel and/or bit width.  Channel split audio is when the individual
channels are stored separately in the original file, such as 2 mono
audio segments being combined to make stereo.  Bit width split audio
is when the samples themselves are stored as separate blocks.  For
example: SoundFont 24 bit support stores the 16 most significant bits
and the least 8 significant bit portions of each individual sample
value in separate areas of the file (thus keeping backwards
compatibility with 16 bit SoundFont readers).</P>
<P>These chunks contain the RawSize and Flags field and 3 other
fields (all optional): ChanCount, SampleSplit and Offsets.</P>
<P>The <B>RawSize</B><SPAN STYLE="font-weight: medium"> field
specifies the size in bytes of the first split chunk.  For example,
if its split stereo then its the size of one channel in bytes.  If
its sample width split audio (and possibly also channel split) then
its the number of bytes of the first split segment.</SPAN></P>
<P>The <B>ChanCount</B> field indicates the channel count for the
audio and defaults to the value 2 (Stereo) which is convenient for
channel split stereo audio.  The value 1 may be specified for bit
width split mono audio.</P>
<P>The <B>SampleSplit</B><SPAN STYLE="font-weight: medium"> chunk
indicates that the individual sample values themselves are split into
separate blocks.  This chunk contains an integer divided into 3 bit
fields (total of 5 bits used) as indicated by the following diagram:</SPAN></P>
<TABLE WIDTH=422 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=64>
	<COL WIDTH=82>
	<COL WIDTH=71>
	<COL WIDTH=82>
	<COL WIDTH=81>
	<TR VALIGN=TOP>
		<TD WIDTH=64>
			<P>4</P>
		</TD>
		<TD WIDTH=82>
			<P>3</P>
		</TD>
		<TD WIDTH=71>
			<P>2</P>
		</TD>
		<TD WIDTH=82>
			<P>1</P>
		</TD>
		<TD WIDTH=81>
			<P>0</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=64>
			<P>After</P>
		</TD>
		<TD COLSPAN=2 WIDTH=161>
			<P>Most Significant</P>
		</TD>
		<TD COLSPAN=2 WIDTH=171>
			<P>Least Significant</P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>
<P STYLE="margin-bottom: 0in">The <B>Most Significant (MS)</B><SPAN STYLE="font-weight: medium">
and </SPAN><B>Least Significant (LS)</B><SPAN STYLE="font-weight: medium">
fields define the </SPAN><B>byte</B><SPAN STYLE="font-weight: medium">
width of the individual sample components.  In the SoundFont 24 bit
example above, this would be the value 2 for MS (16 bit) and 1 for LS
(8 bit).  The </SPAN><B>After</B><SPAN STYLE="font-weight: medium">
bit defines if the </SPAN><B>MS</B><SPAN STYLE="font-weight: medium">
audio chunk comes before (</SPAN><B>After</B><SPAN STYLE="font-weight: medium">=0)
or after (</SPAN><B>After</B><SPAN STYLE="font-weight: medium">=1)
the </SPAN><B>LS</B><SPAN STYLE="font-weight: medium"> audio chunk. 
</SPAN>Currently only a value of 1 or 2 is valid in <SPAN STYLE="font-weight: medium">the
</SPAN><B>MS </B>and <B>LS </B>fields where the sum is 2 or 3 (for 16
bit or 24 bit split audio respectively).</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The <B>Offsets</B><SPAN STYLE="font-weight: medium">
chunk </SPAN>provides the offsets for the chunks of split audio data.
 In the case of channel only split audio (no SampleSplit chunk) the
offsets are relative to the end of the previous chunk and Offsets[]
contains ChanCount - 1 values (the first chunk is located at offset
0).  In the case of audio which is split by bit width (and possibly
also by channel) the offsets are stored relative to the end of the</P>
<P STYLE="margin-bottom: 0in">first chunk (to provide the needed
flexibility in chunk positioning) and Offsets[] contains ChanCount *
2 - 1 values (Chan0:Split1, Chan1:Split0, Chan1:Split1, etc).</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><B>Note:</B> If only 1 offset value is
expected it can be omitted if its value is 0.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The <B>SmoothLoop</B> chunk is used
only for lossy WavPack audio chunks and is optional.  It defines</P>
<P STYLE="margin-bottom: 0in">a loop which can be used during decode
to attempt to correct loop artifacts created by the lossy compression
(by cross fading or other methods).  Currently the reference
libInstPatch decoder does not yet use this, although it stores it.</P>
<H2 CLASS="western"><A NAME="8.8.CRAM hybrid lossless|outline"></A>8.8CRAM
hybrid lossless</H2>
<P>This feature uses the hybrid encoding mode of WavPack to encode a
much smaller lossy CRAM file with a separate correction file which
when combined results in the original lossless data. The combined
sizes of the files are only slightly larger than the equivalent
lossless CRAM file.  This provides a nice way for users to preview a
potentially large instrument file and then download the rest without
incurring much extra overhead.</P>
<P>The only difference between a <B>.cram</B><SPAN STYLE="font-weight: medium">
lossless and </SPAN><B>.craml</B><SPAN STYLE="font-weight: medium">
lossy file (besides the obvious audio differences) is the D</SPAN><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">ocType
field in the EBML chunk, which is either &ldquo;CRAM&rdquo; or
&ldquo;CRAML&rdquo; respectively and the optional presence of
SmoothLoop chunks in the relocation table for the .</SPAN></FONT><FONT COLOR="#000000"><B>craml
</B></FONT><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">case.</SPAN></FONT></P>
<H3 CLASS="western"><A NAME="8.8.1.CRAM correction file|outline"></A>8.8.1CRAM
correction file</H3>
<P><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">The </SPAN></FONT><FONT COLOR="#000000"><B>.cramc</B></FONT><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">
correction file on the other hand is lacking many chunks of a regular
CRAM file and the DocType is set to &ldquo;CRAMC&rdquo;.  The other
fields of the EBML chunk behave the same as a regular CRAM file
except for the Flags field, which currently shouldn't be written
(although decoders should ignore it if it exists).</SPAN></FONT></P>
<P><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">There
should be the same number of FileChunks present as in the matching
</SPAN></FONT><FONT COLOR="#000000"><B>.craml</B></FONT><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">
file.  Each FileChunk should contain a FileData sub chunk with the
same count and type of WavPackChunks and/or WavPackSplitChunks
containing the WavPack correction data (note that there might not be
any sub chunks if the file contains no audio).  The last FileChunk
should be followed by a FileEnd chunk, as usual.</SPAN></FONT></P>
<P><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">The
FileInfo chunk should be present and contain the FileName and
FileSize chunks and are used as an extra check when matching a </SPAN></FONT><FONT COLOR="#000000"><B>.craml</B></FONT><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">
to a </SPAN></FONT><FONT COLOR="#000000"><B>.cramc</B></FONT><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">
file (although the decoder may optionally  ignore the situation and
attempt to proceed anyways if the FileName and/or FileSize fields
don't match between them).  These fields can also be used to display
what files a correction file is intended for.</SPAN></FONT></P>
<P><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">All other
fields should </SPAN></FONT><FONT COLOR="#000000"><B>not</B></FONT><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">
be present in the correction file, including: RelocTable,
RelocTableChksum, FileMD5 and BinaryMD5 as these are taken from the
associated </SPAN></FONT><FONT COLOR="#000000"><B>.craml</B></FONT><FONT COLOR="#000000"><SPAN STYLE="font-weight: medium">
file.</SPAN></FONT></P>
<H1 CLASS="western"><A NAME="9.Implementation notes|outline"></A>9Implementation
notes</H1>
<H2 CLASS="western"><A NAME="9.1.EBML chunk handling|outline"></A>9.1EBML
chunk handling</H2>
<P>If an unrecognized chunk ID is found while decoding a CRAM file,
it should be ignored.  This allows for backwards compatible additions
which don't affect the decoded output.  Chunks should be written in
the order defined.</P>
<H2 CLASS="western"><A NAME="9.2.Binary compression|outline"></A>9.2Binary
compression</H2>
<P>bzlib or zlib are used for compressing binary for CRAM compressed
files.  The same compressor instance is used for all binary data
within a single file (FileData chunk) in a CRAM archive.  Separate
compressor instances are used for the relocation table and other
files in the archive (the compressor context is flushed between
uses).  This allows for the binary data in separate files and
relocation table(s) to be accessed independently and yet maximize
compression for all the binary data for a single file.  The
relocation table entries are in order of position of the original
uncompressed file, but the compressed data chunks (in FileData chunk)
are not necessarily in the same order. All binary chunks and all
audio chunks will be separately in order of position, but binary
chunks are only written out when needed (compression buffer is full).</P>
<H2 CLASS="western"><A NAME="9.3.Audio compression|outline"></A>9.3Audio
compression</H2>
<P>CRAM utilizes WavPack (default) or FLAC for audio compression. 
Multiple audio segments can be encoded in the same FLAC or WavPack
block (as if they were several audio segments concatenated together).
 This allows the minimization of encoder overhead and could in some
cases be more efficient than encoding many small individual segments
separately.  In addition, the NextEntryOfs relocation chunk can now
be used to indicate that the next audio segment in a chain is not the
next audio relocation entry, allowing for all sample data of a
particular format in a file to be encoded in the same compressed
audio chunk.</P>
<H2 CLASS="western"><A NAME="9.4.FLAC compression|outline"></A>9.4FLAC
compression</H2>
<P>The compressed FLAC data chunks are written without a FLAC header
or STREAMINFO chunk.  Only the raw FLAC encoded frames are written. 
Currently each individual audio segment must use a fixed FLAC block
size.  This block size may be changed between segments though. 
Variable block size encoding may be supported in future CRAM
revisions, but probably not.  Note also that parameters in the FLAC
frame header which reference a STREAMINFO chunk may not be used.</P>
<H2 CLASS="western"><A NAME="9.5.CRAM lossy files|outline"></A>9.5CRAM
lossy files</H2>
<P>The file MD5 of the original data is also stored in lossy <B>.craml</B><SPAN STYLE="font-weight: medium">
files, but the decoder will ignore it if just decoding the lossy file
stand alone (although the binary MD5 can, and should, be used in that
case to verify the binary portions of the file).  It will be used if
the </SPAN><B>.cramc</B><SPAN STYLE="font-weight: medium"> is present
to verify the resulting original lossless data.</SPAN></P>
<P STYLE="font-weight: medium"><BR><BR>
</P>
<DIV ID="sdfootnote1">
	<P CLASS="sdfootnote"><A CLASS="sdfootnotesym" NAME="sdfootnote1sym" HREF="#sdfootnote1anc">1</A>&ldquo;SoundFont&rdquo;
	is a registered trademark of E-mu Systems, Inc.</P>
</DIV>
<DIV ID="sdfootnote2">
	<P CLASS="sdfootnote"><A CLASS="sdfootnotesym" NAME="sdfootnote2sym" HREF="#sdfootnote2anc">2</A>GigaSampler
	is a registered trademark of <FONT SIZE=2>Nemesys Music. Technology,
	Inc.</FONT></P>
</DIV>
</BODY>
</HTML>